# This script accepts a tab separated files, with the junction co-ordinate key as first column and the corresponding
# sequence as the second column. The junction co-ordinate key should be in the following format :
# 'chr__start__end__txID__exonNumber__strand'. The script required two separate files for start and end of exon
# junctions. The final output of the script will be a fasta file containing sequences of all possible backsplicing
# junctions. This fasta file can then be used to generate a bwa / STAR index.

# Import required libraries
import pandas
import numpy
import os
from argparse import ArgumentParser


def parse_seq_file(f):
    """
    This function parses relevant information from the 'key' column in the input dataframe.
    :param f: Full path of the input dataframe as given in args.exon_start and args.exon_ends
    :return df: Parsed dataframe
    """
    # Read input dataframe.
    df = pandas.read_csv(f, sep='\t', names=['key', 'seq'])
    # Split 'key' column to extract relevant information.
    df.index = map(lambda x: x.split('__')[3] + '__' + x.split('__')[4], df['key'])
    df['tx'] = map(lambda x: x.split('__')[3], df['key'])
    df['exon_num'] = map(lambda x: x.split('__')[4], df['key'])
    df['strand'] = map(lambda x: x.split('__')[5], df['key'])
    return df


def generate_backsplicing_junction_seqs(starts, ends):
    """
    This function concatenates the sequences from two backsplicing exons to generate a single backsplicing junction
    sequence. This will be done for all possible combinations of backsplicing exons.
    :param starts: Dataframe for exon starts.
    :param ends: Dataframe for exon ends.
    :return d: Dictionary with the backsplicing junction name as key and the corresponsing sequence as value
    """
    # Group starts dataframe by transcript ID and iterate over each group / transcript.
    start_grouped = starts.groupby('tx')
    d = dict()
    for name, grp in start_grouped:
        # Check if the transcript has more than 3 exons. A transcript with 3 or less exons cannot form circular RNAs.
        if list(grp['exon_num'])[-1] > 3:
            # Subset ends dataframe for the same current transcript
            df = ends[ends['tx'] == name]
            # Since order of exons matters, '+' and '-' strands are parsed separately. All backsplicing exon
            # combinations for each transcript are generated by looping over all exons in the transcript. The 5' and 3'
            # exons are excluded from the loops, since they cannot form circular RNAs.
            if '+' in list(grp['strand']):
                for i in range(1, len(grp) - 2):
                    for j in range(i + 1, len(grp) - 1):
                        seq = list(df['seq'])[j] + list(grp['seq'])[i]
                        ind = list(df.index)[j] + ':' + list(grp.index)[i]
                        d[ind] = seq

            if '-' in list(grp['strand']):
                for i in range(1, len(grp) - 2):
                    for j in range(i + 1, len(grp) - 1):
                        seq = list(df['seq'])[i] + list(grp['seq'])[j]
                        ind = list(df.index)[i] + list(grp.index)[j]
                        d[ind] = seq
    return d


def main():
    parser = ArgumentParser(description="Generate backsplicing junction index.")
    parser.add_argument("--exon_starts", help="Full path and name of file for exon start sequences")
    parser.add_argument("--exon_ends", help="Full path and name of file for exon end sequences")
    parser.add_argument("--output_dir", help="Full path to output directory")
    args = parser.parse_args()

    if os.path.isfile(args.exon_starts) and os.path.isfile(args.exon_ends):
        exon_starts = parse_seq_file(args.exon_starts)
        exon_ends = parse_seq_file(args.exon_ends)
        backsplicing_juncs = generate_backsplicing_junction_seqs(exon_starts, exon_ends)
        f = open(args.output_dir + 'backsplicing_exons_seqs.fasta', 'w')
        for i in backsplicing_juncs.keys():
            f.write('>%s\n' % i)
            f.write('%s\n' % backsplicing_juncs[i])
        f.close()
    else:
        parser.error('Exon Starts or Exon Ends file not found !')


if __name__ == '__main__':
    main()
